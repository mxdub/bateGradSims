---
title: "Untitled"
author: "MD"
date: "2024-02-13"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(bateGradSims)
```

## The package

Can be find [here](https://github.com/mxpw/bateGradSims) along with some explanations.

### Context

blabla what's the best sampling procedure depending on species/population ?

### Aim 

[TO COMPLETE]

The package allows to 

+ simulate reproduction among individuals (considered as dioecious but could be extented to monoecious species with few changes), 
+ simulate sampling procedures (fix, prorata, random, or any user-defined sampling method)
+ get (partial) Bateman gradients and compare sampling procedures "easily"

## Core functions

Function are defined to be flexible, user should check function documentation (not all informations are provided here, at least for now).

### Population simulation

Simulating reproduction among individuals follows the following steps

#### Set populations parameters

We first need to define populations size. Let's assume a population with 50 females and 45 males. 

```{r}
n_females = 50
n_males = 45
```

Then, parameters for gametes production. For now, gametes production follows either (rounded) Gaussian or Poisson distribution. Minimal arguments are the expected number of gametes by female and the overall gametes ratio male/female (i.e. with a ratio of 10, males have on average ten more gametes than females), the default behavior is to use Poisson distribution for female and Gaussian distribution for male (with a default variation coefficient of 10%). Others arguments can be see in the doc.

Let's define minimal parameters 

```{r}
n_gamete_fem = 200
ratio_gamete = 10
```


#### Get by individual gametes

And get the gametes by individual.

```{r}
gametes = gametes_drawing(n_females = n_females, n_males = n_males,
                          mean_gamete_female = n_gamete_fem, ratio_gamete = ratio_gamete)

```

The function return a list with two elements : (i) gametes by female, (ii) gametes by male. 

__Note__ : here, and everywhere after, the sequence order is very important since individuals are only known by their index in all vectors and lists (not a good coding choice - not sure how to implement better code in R).

```{r}
gametes
```

#### Pollen export

This part is central to constrain how males export gametes on females. See the details in the vignette(XXX) (en cours...). 

For now, one function can be used to get destination of pollens. 

bon je fais en bref ici, car je vais probablement changer le code prochainement. Mais en l'état, le comportement par defaut.

Un unique parametre, le __pollen_repartition__ : export très hétérogène lorsque la valeur est petite, export très homogène lorsque la valeur est grande. L'hétérogénéité de répartition pour les femelles entre males est identique. 

Les graphiques de gauche, donnent la répartition des grains de pollen sur les femelles (couleurs) pour 15 males tirés au hasard (les lignes). Les graphiques de droite, la distribution du nombre de femelles atteintes par male. 

```{r}
pollen_repartition = pollen_export(n_females = n_females,
                                    gametes_by_male = gametes$gam_male,
                                   pollen_repartition = 0.01,
                                    plot = T)
```


```{r}
pollen_repartition = pollen_export(n_females = n_females,
                                    gametes_by_male = gametes$gam_male,
                                   pollen_repartition = 100,
                                    plot = T)
```

Avant d'aller plus loin sur ce paramètre (gérer de l'hétérogénéité entre males pour l'hétérogénéité d'export), on peut considérer le paramètre __baseline_alpha__.

Ce dernier, de taille __n_females__, représente la "capacité" de chaque femelle à "attirer" le pollen...

Par exemple, on peut définir une femelle comme étant "20x plus attractive que les autres, et ce tout en modulant les niveaux d'hétérogénéité.

```{r}

alpha = rep(1, n_females)
alpha[1] = alpha[1] * 20
alpha[10] = alpha[10] * 10

pollen_repartition = pollen_export(n_females = n_females,
                                   baseline_alpha = alpha,
                                    gametes_by_male = gametes$gam_male,
                                   pollen_repartition = 100,
                                    plot = T)

```



```{r}

alpha = rep(1, n_females)
alpha[1] = alpha[1] * 20

pollen_repartition = pollen_export(n_females = n_females,
                                   baseline_alpha = alpha,
                                    gametes_by_male = gametes$gam_male,
                                   pollen_repartition = 0.1,
                                    plot = T)

```

Si on revient à la situation sans attractivité différentielle des femelles, on peut maintenant moduler l'hétérogénéité d'export pour les males.

La valeur de pollen_repartition peut être remplacée par un vecteur de taille n_males donnant l'hétérogénéité pour chaque males, par exemple:

```{r}

males_heterogeneity = rep(-2, n_males)
males_heterogeneity[1:10] = 2

pollen_repartition = pollen_export(n_females = n_females,
                                    gametes_by_male = gametes$gam_male,
                                   pollen_repartition = males_heterogeneity,
                                    plot = T)

```

__Note__ Les valeurs données ainsi sont de nature differente de l'unique valeur donnée à pollen_repartition (cf. partie précédemente), les valeurs pour les males sont en fait des log10 des valeurs de pollen repartition (pour une valeur de pollen repartition de 0.01 pour un male, il faut fournir la valeur -2, pour 100 : 2). Cette petite transformation permet de tirer ces valeurs dans une distribution Gaussienne comme suit : 

```{r}

pollen_repartition = pollen_export(n_females = n_females,
                                    gametes_by_male = gametes$gam_male,
                                   pollen_repartition = list(mean = 0.2, sd = 1),
                                    plot = T)

```


En l'état, c'est tout ce que l'on peut faire avec cette fonction (on peut très bien gérer à la fois les hétérogénéités entre mâles et des différences d'attractivité entre femelle). Il faut cependant faire un peu attention :

__Points d'attention__

- Dépendance à $\alpha_0$ : les niveaux d'hétérogénité pour l'export sont en fait controler par un paramètre $\alpha_0 = \sum_{i=0}^{n_{females}} \alpha_i * pollen\_repartition$, ils sont donc dépendant du nombre de femelles, du vecteur alpha et du paramètre de pollen repartition. En l'état, c'est probablement dangereux de faire varier deux des trois paramètres à la fois. 
- Dans le même ordre d'idée, la notion de X fois plus attractives est trompeuse (il me semble) - pour les mêmes raisons.
- Je vais essayer de travailler sur ce point pour améliorer ça, je pense qu'il y a des choses à faire encore.

__Trucs à venir__

On pourrait vraiment faire plein de choses avec des distributions de Dirichlet et on pourrait dailleurs même s'en passer dans certain cas (en faisant des tirages dans des multinomiales directement). Je pense qu'on peut creuser sur la construction de matrices pour représenter des situations biologiques (que l'on avait un peu discuté la dernière fois): histoires de phénologie, de localisation spatiales, ou d'autres formes d'export non aléatoires. Je pense qu'il existe les outils pour gérer assez facilement ce genre de choses avec les réseaux - ça me botte bien comme sujet. 

__Note__ : At this point (but also after), exact Matting Success (observed) can be computed from pollen repartition :

```{r}
mso = ms_obs(pollen_repartition)
mso
```


#### Get male competitive values

Males have to get a competitive value (as implemented here, this value is intrinsic to males, and males hierarchy won't change depending on context - when two pollen grains land on a stigma for only one ovule, fecondation probabilities for each male is directly proportional to their comp. values). Two functions can be used here.

First, one can get competitive values from any R-defined function. The distribution should be provided through the distrib parameter, and distribution parameters through the dist_params parameter. The competitive values distribution can be plot using the plot = T argument. Lastly, when used distributions are not bounded to positives values, the default behavior is to shift the competitive values to be all above zero (a warning is then displayed).

```{r}
# Uniform
males_comp_values = get_male_comp_values(n_males = n_males, distrib = sample, dist_params = list(x=1:100, replace = TRUE), plot = T)

# Gaussian
males_comp_values = get_male_comp_values(n_males = n_males, distrib = rnorm, dist_params = list(mean = 100, sd = 10), plot = T)

# Beta
males_comp_values = get_male_comp_values(n_males = n_males, distrib = rbeta, dist_params = list(shape1 = 5, shape2 = 5), plot = T)
```

Second, the competitive values can be drawn from a conditional Normal distribution, depending on another individual characteristic. Additional rho, the correlation between the feature and comp. values, and the feature have to be provided (parameter feature). (might try in future to implement that for other distributions). For example, inversely correlated with gametes production. 

```{r}

males_comp_values = get_male_comp_values_from_feature(mean_comp_value = 10,
                                                      sd_comp_value = 20,
                                                      rho = -0.5,
                                                      feature = gametes$gam_male,
                                                      plots=T)

```


#### Pollen competition on sigma

Now, pollen repartition is known as well as male competitive values. Who will win access to ovula is determined by male comp. values. 

```{r}

fertilized_eggs = pollen_competition(pollen_repartition, males_comp_values, gametes$gam_female)

```

Some info on pollen limitation are displayed, and the function return a list of size n_female: each entry contain males' identity for each eggs.

#### Eggs abortion

If needed.

```{r}

fertilized_eggs = eggs_abortion(fertilized_eggs, aborded_fraction = 0)

```

#### Correlated paternity

Correlated paternity can be computed from fertilized_eggs list

```{r}

pop_average_rp(correlated_paternity = correlated_paternity(fertilized_eggs),
                                 n_males = n_males)

```

### Sampling

Various sampling can be used - check detailled documentation for each. 

Some examples : 

```{r}
sampled_fertilized_eggs = sampling_groundtruth(fertilized_eggs)
get_sexual_selection_components(fertilized_eggs = fertilized_eggs,
                                sampled_fertilized_eggs = sampled_fertilized_eggs,
                                n_males = n_males)

sampled_fertilized_eggs = sampling_fixed(fertilized_eggs, n_males, by_female_samples = 50, undercount_female = 'keep')
get_sexual_selection_components(fertilized_eggs = fertilized_eggs,
                                sampled_fertilized_eggs = sampled_fertilized_eggs,
                                n_males = n_males)

sampled_fertilized_eggs = sampling_prorata(fertilized_eggs, n_males, by_female_prop = 0.5, min_threshold = 30,
                                           undercount_female = 'remove_and_upsample', upsample_strategy = 's1', upsampling_plot = T)
get_sexual_selection_components(fertilized_eggs = fertilized_eggs,
                                sampled_fertilized_eggs = sampled_fertilized_eggs,
                                n_males = n_males)

sampled_fertilized_eggs = sampling_random(fertilized_eggs, n_males)
get_sexual_selection_components(fertilized_eggs = fertilized_eggs,
                                sampled_fertilized_eggs = sampled_fertilized_eggs,
                                n_males = n_males)
```

While each method can be used one by one, a convenient wrapper can be used. It allows to : (i) specify multiple sampling strategy (that will be evaluate in turn), (ii) replicate each strategy a given number of time. Note that groundtruth is automatically computed (without need for further specification).

```{r}
# To avoid repetition and extra-gathering work, one can use the sampling() function to use multiple sampling methods (given as list as follow)
# Better to specify all parameters (even default ones) if one wants to keep tracks of all of them in outputs
n_eggs_sampled = 2000
methods = list(fixed = list(method = "sampling_fixed", params = list(total_samples = n_eggs_sampled, undercount_female = 'remove')),
               prorata = list(method = "sampling_prorata", params = list(total_samples = n_eggs_sampled, min_threshold = 10,
                                                                         undercount_female = 'remove', upsample_strategy = 's1')),
               prorata = list(method = "sampling_prorata", params = list(total_samples = n_eggs_sampled, min_threshold = 10,
                                                                         undercount_female = 'remove', upsample_strategy = 's2')),
               random = list(method = "sampling_random", params = list(total_samples = n_eggs_sampled)))

# The n_rep apply to all sampling methods
samples = sampling(fertilized_eggs, n_males, methods = methods, mso = mso, gametes = gametes, n_rep = 2)
```

Some desciptive statistics can then be obtained :

```{r}
# Descriptive stats can be obtained from samples
descriptive_stats(samples)
```

### Gradients

Lastly, Bateman gradients ; return results contains two elements : (i) one named 'gradients' with sampling_method, parameters, inferred gradients and differences to base gradients, (ii) one names 'glms' with sampling_method, parameters, parameters_string, data, and glms results

```{r}

gradients = fit_gradients(samples, scaled = TRUE)

gradients

```

### Next

A bit more to come soon. 
