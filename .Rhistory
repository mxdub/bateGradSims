if(length(x) == 1) return(x)
sample(x, size = min(length(x), size), prob = prob)
}
male_gamete_repartition
pollen_repartition
library(bateGradSims)
n_females = 100
n_males = 110
n_gamete_fem = 50
ratio_gamete = 10
cv_normal_male = 0.1
# Get gametes
gametes = gametes_drawing(n_females = n_females, n_males = n_males,
mean_gamete_female = n_gamete_fem, ratio_gamete = ratio_gamete,
male_distrib_params = cv_normal_male)
# Get males comp. values
male_comp_values = get_male_comp_values(n_males = n_males, sd_comp = 10, plot = T)
# Get pollen repartition
pollen_repartition = pollen_export(n_females = n_females,
gametes_by_male = gametes$gam_male,
pollen_repartition = list(mean = -2, sd = 0.2),
plot = T)
# Mating Success (exact) can then be computed from the pollen_repartition, e.g.,
mso_female = apply(pollen_repartition, 1, FUN = function(x) sum(x>0) )
mso_male = apply(pollen_repartition, 2, FUN = function(x) sum(x>0) )
mso_female
mso_male
gametes
dim(pollen_repartition)
n_females = 100
n_males = 110
n_gamete_fem = 50
ratio_gamete = 10
cv_normal_male = 0.1
# Get gametes
gametes = gametes_drawing(n_females = n_females, n_males = n_males,
mean_gamete_female = n_gamete_fem, ratio_gamete = ratio_gamete,
male_distrib_params = cv_normal_male)
# Get males comp. values
male_comp_values = get_male_comp_values(n_males = n_males, sd_comp = 10, plot = T)
# Get pollen repartition
pollen_repartition = pollen_export(n_females = n_females,
gametes_by_male = gametes$gam_male,
pollen_repartition = list(mean = -2, sd = 0.2),
plot = T)
dim(pollen_repartition)
male_comp_values
gametes$gam_male
# Get pollen repartition
pollen_repartition = pollen_export(n_females = n_females,
gametes_by_male = gametes$gam_male,
# pollen_repartition = list(mean = -2, sd = 0.2),
plot = T)
pollen_repartition
dim(pollen_repartition)
library(bateGradSims)
library(bateGradSims)
n_females = 100
n_males = 110
n_gamete_fem = 50
ratio_gamete = 10
cv_normal_male = 0.1
# Get gametes
gametes = gametes_drawing(n_females = n_females, n_males = n_males,
mean_gamete_female = n_gamete_fem, ratio_gamete = ratio_gamete,
male_distrib_params = cv_normal_male)
# Get males comp. values
male_comp_values = get_male_comp_values(n_males = n_males, sd_comp = 10, plot = T)
# Get pollen repartition
pollen_repartition = pollen_export(n_females = n_females,
gametes_by_male = gametes$gam_male,
pollen_repartition = list(mean = -2, sd = 0.2),
plot = T)
library(bateGradSims)
library(bateGradSims)
n_females = 100
n_males = 110
n_gamete_fem = 50
ratio_gamete = 10
cv_normal_male = 0.1
# Get gametes
gametes = gametes_drawing(n_females = n_females, n_males = n_males,
mean_gamete_female = n_gamete_fem, ratio_gamete = ratio_gamete,
male_distrib_params = cv_normal_male)
# Get males comp. values
male_comp_values = get_male_comp_values(n_males = n_males, sd_comp = 10, plot = T)
# Get pollen repartition
pollen_repartition = pollen_export(n_females = n_females,
gametes_by_male = gametes$gam_male,
pollen_repartition = list(mean = -2, sd = 0.2),
plot = T)
pollen_repartition
dim(pollen_export())
dim(pollen_repartition)
?sample
library(bateGradSims)
library(bateGradSims)
library(bateGradSims)
n_females = 100
n_males = 110
n_gamete_fem = 50
ratio_gamete = 10
cv_normal_male = 0.1
# Get gametes
gametes = gametes_drawing(n_females = n_females, n_males = n_males,
mean_gamete_female = n_gamete_fem, ratio_gamete = ratio_gamete,
male_distrib_params = cv_normal_male)
# Get males comp. values
male_comp_values = get_male_comp_values(n_males = n_males, sd_comp = 10, plot = T)
# Get pollen repartition
pollen_repartition = pollen_export(n_females = n_females,
gametes_by_male = gametes$gam_male,
pollen_repartition = list(mean = -2, sd = 0.2),
plot = T)
# Mating Success (exact) can then be computed from the pollen_repartition, e.g.,
mso_female = apply(pollen_repartition, 1, FUN = function(x) sum(x>0) )
mso_male = apply(pollen_repartition, 2, FUN = function(x) sum(x>0) )
# Pollen competition, i.e., who fertilized who
pollen_competi
library(bateGradSims)
# Pollen competition, i.e., who fertilized who
bateGradSims::pollen_competition(pollen_repartition, males_comp_values, gametes$gam_female)
# Get males comp. values
males_comp_values = get_male_comp_values(n_males = n_males, sd_comp = 10, plot = T)
# Get pollen repartition
pollen_repartition = pollen_export(n_females = n_females,
gametes_by_male = gametes$gam_male,
pollen_repartition = list(mean = -2, sd = 0.2),
plot = T)
# Mating Success (exact) can then be computed from the pollen_repartition, e.g.,
mso_female = apply(pollen_repartition, 1, FUN = function(x) sum(x>0) )
mso_male = apply(pollen_repartition, 2, FUN = function(x) sum(x>0) )
# Pollen competition, i.e., who fertilized who
pollen_competition(pollen_repartition, males_comp_values, gametes$gam_female)
# Pollen competition, i.e., who fertilized who
pollen_competition(pollen_repartition, males_comp_values, gametes$gam_female)
library(bateGradSims)
n_females = 100
n_males = 110
n_gamete_fem = 50
ratio_gamete = 10
cv_normal_male = 0.1
# Get gametes
gametes = gametes_drawing(n_females = n_females, n_males = n_males,
mean_gamete_female = n_gamete_fem, ratio_gamete = ratio_gamete,
male_distrib_params = cv_normal_male)
# Get males comp. values
males_comp_values = get_male_comp_values(n_males = n_males, sd_comp = 10, plot = T)
# Get pollen repartition
pollen_repartition = pollen_export(n_females = n_females,
gametes_by_male = gametes$gam_male,
pollen_repartition = list(mean = -2, sd = 0.2),
plot = T)
# Mating Success (exact) can then be computed from the pollen_repartition, e.g.,
mso_female = apply(pollen_repartition, 1, FUN = function(x) sum(x>0) )
mso_male = apply(pollen_repartition, 2, FUN = function(x) sum(x>0) )
# Pollen competition, i.e., who fertilized who
pollen_competition(pollen_repartition, males_comp_values, gametes$gam_female)
# Pollen competition, i.e., who fertilized who
fertilized_eggs = pollen_competition(pollen_repartition, males_comp_values, gametes$gam_female)
fertilized_eggs
setwd("~/home_projets/Bateman Gradient")
library(gtools)
library(tidyverse)
library(cowplot)
#####################
n_female = 250
n_male = 100
n_gamete_fem = 50
ratio_gamete = 20 # How many more gamete male produced
# Number of gamete for each male
gamete_by_male = rpois(n_male, lambda = ratio_gamete * n_gamete_fem)
cv_gamete_male = 0.1 # Coefficient of variation - as % (e.g., 0.1 => 10%)
gamete_by_male = pmax(0, round(rnorm(n_male,
mean = ratio_gamete * n_gamete_fem,
sd = (cv_gamete_male * ratio_gamete * n_gamete_fem) )))
# Use Quasi Poisson or Negative binomiale instead ?
# Number of gamete for each female
gamete_by_female = rpois(n_female, lambda = n_gamete_fem)
# Same question, qPoisson / nBinom ?
# Male competitive effect
comp_strength = 0 # 0 no comp, more, more compet
male_comp = rnorm(n_male, 1, comp_strength)
male_comp = male_comp - min(male_comp, 0) + 0.01
hist(male_comp)
# Draw gamete export distribution
# From low value, e.g., 0.01 -> very high heterogeneity almost only one female pollinated, to high value, e.g., 100 -> homogeneous
# Note, it could be a vector instead of unique value (i.e. if heterogenity depends on male identity)
pollen_repartition = 0.01
# pollen_repartition = list(mean = -1, sd = 0.75)
# pollen_repartition = list(-1, 0.75)
male_gamete_export_heterogeneity = rep(pollen_repartition, n_male)
# male_gamete_export_heterogeneity = 10^rnorm(n_male, -1, 0.75)
# Could include some variability among female for 'receptivity'/'attractivness' ?
base_line_alpha = rep(1, n_female)
dirichlet_draw = sapply(male_gamete_export_heterogeneity, FUN = function(x) gtools::rdirichlet(1, alpha = base_line_alpha * x) )
male_gamete_repartition = matrix(nrow = n_female, ncol = n_male)
for(i in 1:n_male)
male_gamete_repartition[,i] = rmultinom(1, gamete_by_male[i], dirichlet_draw[,i])
tp = dirichlet_draw[,sample(dim(dirichlet_draw)[2], 10)] %>%
as_tibble() %>%
add_rownames() %>%
pivot_longer(-rowname)
ggplot(tp, aes(x = name, y = value, fill = rowname))+
geom_bar(stat = 'identity', color="black")+
coord_flip()+
theme(legend.position = 'none')+
labs(x = "Males", y = "Pollen repartition among females")
hist(apply(male_gamete_repartition, 2, FUN = function(x) sum(x>0)))
# New sample method
sample_handmade = function(x, size, prob = NULL){
if(length(x) == 0 || size == 0 || is.na(size)) return(NULL)
if(length(x) == 1) return(x)
sample(x, size = min(length(x), size), prob = prob)
}
# Compute MSo
mso_female = apply(male_gamete_repartition, 1, FUN = function(x) sum(x>0) )
mso_male = apply(male_gamete_repartition, 2, FUN = function(x) sum(x>0) )
# Sperm competition
female_desc = list()
for(f in 1:n_female){
vector_to_sample = c()
vector_competition = c()
for(m in 1:n_male){
vector_to_sample = c(vector_to_sample, rep(m, male_gamete_repartition[f, m]))
vector_competition = c(vector_competition, rep(male_comp[m], male_gamete_repartition[f, m]) )
}
if(length(vector_to_sample) == 0){
female_desc[f] = list(NULL)
}else{
female_desc[[f]] = sample_handmade(vector_to_sample,
size = gamete_by_female[f], # Carefull, some pollen limitation might exists ! Meaning true draw size can be lower than gamete_by_female
prob = vector_competition / sum(vector_competition))
}
}
####
#### Bateman gradient from full data (absolute knowledge)
####
msg_female = unlist(lapply(female_desc, FUN = function(x) length(unique(x)) ))
rsg_female = unlist(lapply(female_desc, length))
msg_male = rep(0, n_male)
rsg_male = rep(0, n_male)
for(m in 1:n_male){
msg_male[m] = sum(unlist(lapply(female_desc, FUN = function(x) m %in% x )))
rsg_male[m] = sum(unlist(female_desc) == m)
}
#### Sampling ####
# What to do when a female doesn't have enough eggs ?
## i) Taking them anyway ('keep')
## ii) Remove these female from dataset ('remove')
sampling_abs = function( n_genotypage = 1000, undercount_female = 'remove' ){
sample_by_female = n_genotypage / n_female
total_eggs = sum(unlist(lapply(female_desc, length)))
print(paste0("Total number of eggs : ", total_eggs, " with ", n_genotypage," to be genotype"))
female_to_remove = rep(F, n_female)
if( any( lapply(female_desc, length) < sample_by_female ) ){
print(paste0("Some female(s) doesn't have enough fruits! Use strategy '",undercount_female,"'"))
if(undercount_female == 'keep'){
female_desc_reduced = lapply(female_desc,
FUN = function(x) sample_handmade(x, size = sample_by_female) )
}else if(undercount_female == 'remove'){
female_desc_reduced = lapply(female_desc,
FUN = function(x) {
if(length(x) >= sample_by_female)
sample_handmade(x, size = sample_by_female)
else
NULL
})
# Keep track of female w/o enough eggs to be considered
female_to_remove = unlist(lapply(female_desc, length)) < sample_by_female
print(paste0("Female removed from dataset : ",sum(female_to_remove)," idv(s) (",sum(female_to_remove)/length(female_to_remove),"%)"))
}else{
print(paste0("Strategy ", undercount_female, "doesn't exists !"))
}
}else{
female_desc_reduced = lapply(female_desc,
FUN = function(x) sample(x, size = sample_by_female, replace = FALSE) )
}
msg_female_abs = unlist(lapply(female_desc_reduced, FUN = function(x) length(unique(x)) ))
rsg_female_abs = unlist(lapply(female_desc, length)) # Compute on non-reduced dataset !
msg_female_abs[female_to_remove] = NA
rsg_female_abs[female_to_remove] = NA
msg_male_abs = rep(0, n_male)
rsg_male_abs = rep(0, n_male)
for(m in 1:n_male){
msg_male_abs[m] = sum(unlist(lapply(female_desc_reduced, FUN = function(x) m %in% x )))
rsg_male_abs[m] = sum(unlist(female_desc_reduced) == m)
}
return(list(msg_female = msg_female_abs,
rsg_female = rsg_female_abs,
msg_male = msg_male_abs,
rsg_male = rsg_male_abs))
}
# What to do when a female doesn't have enough eggs ? (less than min_threshold)
## Two way to not having enough eggs :
#### (a) total eggs * theo_perc < min_threshold (cond. 1) AND total eggs >= min_treshold (cond. 2)
#### (b) total eggs * theo_perc < min_threshold (cond. 1) AND total eggs < min_treshold (cond. 2)
## Strategies
### ()    Do nothing ? - undercount_female = 'keep'
### (i)   remove females with (a) or (b) - undercount_female = 'remove'
### (ii)  remove females with (b) and upsample females in (a) case to min_threshold,
###       remove all up eggs from females not in a/b cases - undercount_female = 'remove_and_upsample'
## Upsampling methods...
### (i)   Remove one to female with the most kept eggs, then resort, and restart until no left eggs (method m1)
### (ii)  If n eggs to redistribute, remove one to first n female, restart until no left eggs (method m2)
### Each method lead to a different re-repartition
### (either 'truncating' each side of the distribution, or truncating at left but reduced 'intercept' at right)
# Carefull when number of eggs by idv is low ... not sure about the behavior (rounding close from zero) - will be update
# What to do when theo_perc * total eggs ~ e.g., 0.3 (e.g. an idv with 4 eggs, and theo_prec = 1%) - take at least one, or not ?
sampling_prorata = function( n_genotypage = 1000, min_threshold = 3, undercount_female = 'remove', upsample_strategy = "m1" ){
theoretical_perc = n_genotypage / length(unlist(female_desc))
print(paste0("Initial theoretical % to be sample : ", round(theoretical_perc, 2), " %"))
total_eggs = sum(unlist(lapply(female_desc, length)))
print(paste0("Total number of eggs : ", total_eggs, " with ", n_genotypage," to be genotype"))
if(min_threshold*n_female>n_genotypage){
print("!!! Required minimal threshold is not compatible with genotype total expected !!!")
return(NULL)
}
# Check eggs by female
condition_one = unlist(lapply(female_desc, FUN = function(x) round(theoretical_perc * length(x)) < min_threshold ))
condition_two = unlist(lapply(female_desc, FUN = function(x) length(x) < min_threshold ))
if( any(condition_two) )
print(paste0("Some female(s) (",sum(condition_two),", ",mean(100*condition_two)," %) doesn't have enough fruits at all !"))
if( any(condition_one) )
print(paste0("Some female(s) (",sum(condition_one),", ",round(100*mean(condition_one),2)," %) will have less than expected fruits after sampling !",
"(",sum(condition_one & !condition_two),", ", round(100*mean(condition_one & !condition_two), 2)," %) of them can be upsampled"))
print(paste0("Sampling with strategy '",undercount_female,"'"))
female_to_remove = rep(F, n_female)
# In all cases, can be update later
female_desc_reduced = lapply(female_desc, FUN = function(x) sample_handmade(x, size = round(theoretical_perc * length(x))) )
if(undercount_female == 'remove'){ # No change for calculus I think at first...
female_to_remove = condition_one
print(paste0("--> ",sum(condition_one)," (",round(100*mean(condition_one),2)," %) female(s) will be removed"))
}else if(undercount_female == 'remove_and_upsample'){
female_to_remove = condition_two
print(paste0("--> ",sum(condition_two)," (",round(100*mean(condition_two),2)," %) female(s) will be removed"))
# Eggs to consider
eggs = unlist(lapply(female_desc, FUN = function(x) round(theoretical_perc * length(x))))
eggs[female_to_remove] = NA
eggs = eggs - min_threshold
plot(sort(eggs))
if( sum(eggs, na.rm=T) < 0 ){
stop("It is not possible to upsample !")
}
sorted_idx = sort(eggs, decreasing = T, na.last = T, index.return = T)$ix
print(paste0("Upsample with strategy ", upsample_strategy))
if(upsample_strategy == 'm1'){
n_transfert = -sum(eggs[eggs < 0], na.rm = T)
eggs[eggs < 0] = 0
while(n_transfert > 0){
eggs[sorted_idx][1] = eggs[sorted_idx][1] - 1
sorted_idx = sort(eggs, decreasing = T, na.last = T, index.return = T)$ix
n_transfert = n_transfert - 1
}
}else if(upsample_strategy == "m2"){
# Method 2
n_transfert = -sum(eggs[eggs < 0], na.rm = T)
n_transfert = 300
eggs[eggs < 0] = 0
while(n_transfert > 0){
aside = 0
local_transfert = n_transfert
if(n_transfert > length(eggs[!is.na(eggs)])){
aside = n_transfert - length(eggs[!is.na(eggs)])
local_transfert = length(eggs[!is.na(eggs)])
}
eggs[sorted_idx][1:local_transfert] = eggs[sorted_idx][1:local_transfert] - 1
n_transfert = -sum(eggs[eggs < 0], na.rm = T) + aside
eggs[eggs < 0] = 0
}
}else{
print(paste0("Strategy ", upsample_strategy, " doesn't exists !"))
}
# After upsampling
points(sort(eggs), col = 'red')
# Recompute Female reduced
eggs = eggs + min_threshold
for(i in 1:length(female_desc)){
female_desc_reduced[[i]] = sample_handmade(female_desc[[i]], size = eggs[i])
}
}else{
print(paste0("Strategy ", undercount_female, "doesn't exists !"))
}
print(paste0("Number of fruits to be genotype = ", length(unlist(female_desc_reduced))))
msg_female_pr = unlist(lapply(female_desc_reduced, FUN = function(x) length(unique(x)) ))
rsg_female_pr = unlist(lapply(female_desc, length)) # Compute on non-reduced dataset !
msg_female_pr[female_to_remove] = NA
rsg_female_pr[female_to_remove] = NA
msg_male_pr = rep(0, n_male)
rsg_male_pr = rep(0, n_male)
for(m in 1:n_male){
msg_male_pr[m] = sum(unlist(lapply(female_desc_reduced, FUN = function(x) m %in% x )))
rsg_male_pr[m] = sum(unlist(female_desc_reduced) == m)
}
return(list(msg_female = msg_female_pr,
rsg_female = rsg_female_pr,
msg_male = msg_male_pr,
rsg_male = rsg_male_pr))
}
sampling_random = function( n_genotypage = 1000){
# Make descendant center results
males_ = unlist(female_desc)
females_ = c()
for(f in 1:length(female_desc))
females_ = c(females_, rep(f, length(female_desc[[f]])) )
spl = cbind(females_, males_)[sample(1:length(males_), size = n_genotypage),] %>% as_tibble()
# Female RSg (from # of descendant)
rsg_female_rd = unlist(lapply(female_desc, length)) # Compute on non-reduced dataset !
# Computation by female
female_gb = spl %>% group_by(females_) %>% summarise(ms = n_distinct(males_))
msg_female_rd = rep(NA, n_female)
for(i in 1:nrow(female_gb))
msg_female_rd[ female_gb[[i, 1]] ] = female_gb[[i, 'ms']]
# Computation by male
male_gb = spl %>% group_by(males_) %>% summarise(ms = n_distinct(females_), rs = n())
msg_male_rd = rep(NA, n_male)
rsg_male_rd = rep(NA, n_male)
for(i in 1:nrow(male_gb)){
msg_male_rd[ male_gb[[i, 1]] ] = male_gb[[i, 'ms']]
rsg_male_rd[ male_gb[[i, 1]] ] = male_gb[[i, 'rs']]
}
return(list(msg_female = msg_female_rd,
rsg_female = rsg_female_rd,
msg_male = msg_male_rd,
rsg_male = rsg_male_rd))
}
#### Plotting ####
output_df = list()
output_df[['base']] = tibble(mso = c(mso_female, mso_male),
msg = c(msg_female, msg_male),
rsg = c(rsg_female, rsg_male),
n_gam = c(gamete_by_female, gamete_by_male),
sex = c(rep("F", n_female), rep("M", n_male)),
sampling_method = "base") %>%
group_by(sex) %>%
mutate_at(vars(mso:rsg), ~ .x / mean(.x, na.rm = T)) # Might be dependent on a condition
n_geno = 6000
for( sm in c('abs', 'pr', 'rd') ){
if(sm == 'abs'){
smpl = sampling_abs(n_genotypage = n_geno, undercount_female = 'remove')
}else if(sm == 'pr'){
smpl = sampling_prorata(n_genotypage = n_geno, min_threshold = 5,  undercount_female = 'remove_and_upsample', upsample_strategy = "m1")
}else if(sm == 'rd'){
smpl = sampling_random(n_genotypage = n_geno)
}
output_df[[sm]] = tibble(mso = c(mso_female, mso_male),
msg = c(smpl$msg_female, smpl$msg_male),
rsg = c(smpl$rsg_female, smpl$rsg_male),
n_gam = c(gamete_by_female, gamete_by_male),
sex = c(rep("F", n_female), rep("M", n_male)),
sampling_method = sm)%>%
group_by(sex) %>%
mutate_at(vars(mso:rsg), ~ .x / mean(.x, na.rm = T)) # Might be dependent on a condition
}
plot_grid(
plot_grid(
ggplot(output_df[['base']], aes(x = msg, y = rsg, color = sex))+
geom_point()+
geom_smooth(method='lm'),
ggplot(output_df[['base']], aes(x = mso, y = rsg, color = sex))+
geom_point()+
geom_smooth(method='lm'),
ncol = 2
),
plot_grid(
ggplot(output_df[['abs']], aes(x = msg, y = rsg, color = sex))+
geom_point()+
geom_smooth(method='lm')+
theme(legend.position = 'none'),
ggplot(output_df[['pr']], aes(x = msg, y = rsg, color = sex))+
geom_point()+
geom_smooth(method='lm')+
theme(legend.position = 'none'),
ggplot(output_df[['rd']], aes(x = msg, y = rsg, color = sex))+
geom_point()+
geom_smooth(method='lm')+
theme(legend.position = 'none'),
ncol = 3),
ncol = 1
)
# Limitation pollinique
print(paste0("Pollen limitation : ", round(100*(1-sum(rsg_female)/sum(gamete_by_female)), 2), " % of eggs are unfertilized"))
fam_ = 'gaussian' # Since data are centered - can use Gaussian model // Check if using raw data, might be better to use Poisson()
slopes = tibble(sex = c('F', 'M', 'F', 'M'),
gamControl = c('Oui', 'Oui', 'Non', 'Non'))
for(sm in names(output_df)){
lm_gamControl = glm(data = output_df[[sm]], rsg ~ (n_gam + msg) * sex, family = fam_)$coefficients
lm_noGamControl = glm(data = output_df[[sm]], rsg ~ (msg) * sex, family = fam_)$coefficients
slopes[[sm]] = c(lm_gamControl[['msg']], lm_gamControl[['msg']]+ lm_gamControl[['msg:sexM']],
lm_noGamControl[['msg']], lm_noGamControl[['msg']] + lm_noGamControl[['msg:sexM']])
}
for(sm in names(output_df)[-1])
slopes[[paste0('delta_', sm)]] = slopes[[sm]] - slopes[['base']]
slopes %>% knitr::kable()
# Not really sampling, exact RS/MS
sampling_groundtruth = function( fertilized_eggs, n_males){
msg_female = unlist(lapply(fertilized_eggs, FUN = function(x) length(unique(x)) ))
rsg_female = unlist(lapply(fertilized_eggs, length))
msg_male = rep(0, n_males)
rsg_male = rep(0, n_males)
for(m in 1:n_males){
msg_male[m] = sum(unlist(lapply(fertilized_eggs, FUN = function(x) m %in% x )))
rsg_male[m] = sum(unlist(fertilized_eggs) == m)
}
return(list(msg_female = msg_female,
rsg_female = rsg_female,
msg_male = msg_male,
rsg_male = rsg_male))
}
sampling_groundtruth(female_desc, n_male)
n_female
n_male
